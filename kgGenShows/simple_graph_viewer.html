<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>知識圖譜可視化器 - 簡易預覽</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Check if D3.js loaded successfully
        function checkD3() {
            if (typeof d3 === 'undefined') {
                console.error('❌ D3.js failed to load, trying fallback...');
                
                // Try alternative CDN
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/d3@7';
                script.onload = function() {
                    console.log('✅ D3.js fallback loaded successfully');
                    if (typeof d3 !== 'undefined') {
                        initWhenReady();
                    } else {
                        showD3Error();
                    }
                };
                script.onerror = function() {
                    console.error('❌ D3.js fallback also failed to load');
                    showD3Error();
                };
                document.head.appendChild(script);
                return false;
            }
            console.log('✅ D3.js loaded successfully');
            return true;
        }
        
        function showD3Error() {
            document.body.innerHTML = `
                <div style="text-align: center; padding: 50px; color: #dc3545;">
                    <h2>❌ D3.js 庫載入失敗</h2>
                    <p>請檢查網路連接或嘗試以下解決方案：</p>
                    <ul style="text-align: left; max-width: 500px; margin: 0 auto;">
                        <li>確保網路連接正常</li>
                        <li>檢查防火牆或代理設置</li>
                        <li>嘗試重新整理頁面</li>
                        <li>聯繫系統管理員</li>
                    </ul>
                </div>
            `;
        }
        
        function initWhenReady() {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', startApp);
            } else {
                startApp();
            }
        }
        
        function startApp() {
            console.log('🚀 Simple viewer - DOM loaded, starting initialization...');
            
            try {
                init();
            } catch (error) {
                console.error('❌ Simple viewer initialization failed:', error);
                console.error('Error details:', error.stack);
                
                // Show error message to user
                const statsElement = document.getElementById('stats');
                if (statsElement) {
                    statsElement.textContent = `初始化失敗：${error.message}`;
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f8f9fa;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            color: #495057;
        }
        
        .graph-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            margin: 0 auto;
            max-width: 1400px;
        }
        
        .controls {
            text-align: center;
            margin-bottom: 15px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 5px;
        }
        
        .controls button {
            margin: 0 5px;
            padding: 5px 15px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .controls button:hover {
            background: #0056b3;
        }
        
        .stats {
            text-align: center;
            margin-bottom: 10px;
            font-size: 14px;
            color: #6c757d;
        }
        
        .node {
            cursor: pointer;
            stroke: #fff;
            stroke-width: 2px;
        }
        
        .node:hover {
            stroke: #333;
            stroke-width: 3px;
        }
        
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1px;
        }
        
        .node-label {
            font-size: 8px;
            fill: #333;
            text-anchor: middle;
            pointer-events: none;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>知識圖譜可視化器 - 簡易預覽</h1>
        <p id="file-info">載入中...</p>
    </div>
    
    <div class="graph-container">
        <div class="controls">
            <button onclick="restartSimulation()">重新啟動</button>
            <button onclick="pauseResume()">暫停/繼續</button>
            <button onclick="centerView()">置中視圖</button>
        </div>
        
        <div class="stats" id="stats">載入中...</div>
        
        <div id="graph" style="width: 100%; height: 600px;"></div>
    </div>

    <script>
        // Global variables for the visualization
        let simulation;
        let nodes = [];
        let links = [];
        let svg;
        let isPaused = false;
        
        // Color scheme for different entity types
        const colorScheme = {
            person: '#ff7f0e',
            location: '#2ca02c',
            literature: '#9467bd',
            concept: '#d62728',
            other: '#1f77b4'
        };
        
        // Initialize the visualization
        function init() {
            console.log('🚀 Simple viewer - Initializing visualizer...');
            
            try {
                // Set up SVG
                console.log('📐 Setting up SVG container...');
                const container = d3.select('#graph');
                
                if (container.empty()) {
                    console.error('❌ Cannot find #graph container element');
                    throw new Error('Graph container element does not exist');
                }
                
                const width = container.node().getBoundingClientRect().width;
                const height = 600;
                console.log(`📏 Container dimensions: ${width} x ${height}`);
                
                svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                console.log('✅ SVG element created successfully');
                
                // Add zoom and pan functionality
                console.log('🔍 Adding zoom and pan functionality...');
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', function(event) {
                        svg.selectAll('g').attr('transform', event.transform);
                    });
                
                svg.call(zoom);
                console.log('✅ Zoom functionality added successfully');
                
                // Create tooltip
                console.log('💬 Creating tooltip...');
                d3.select('body').append('div')
                    .attr('class', 'tooltip')
                    .style('opacity', 0);
                console.log('✅ Tooltip created successfully');
                
                // Load and process data
                console.log('📊 Starting data loading...');
                loadData();
                
            } catch (error) {
                console.error('❌ Initialization failed:', error);
                throw error;
            }
        }
        
        // Load JSON data and create visualization
        async function loadData() {
            console.log('🔄 Simple viewer - Starting data loading...');
            document.getElementById('stats').textContent = '正在載入數據...';
            
            try {
                // Check if specific file is requested via URL parameter
                const urlParams = new URLSearchParams(window.location.search);
                const selectedFile = urlParams.get('file');
                
                console.log(`📁 Requested file: ${selectedFile || 'default file'}`);
                
                // Construct API URL with file parameter if specified
                const apiUrl = selectedFile ? `/api/graph-data?file=${encodeURIComponent(selectedFile)}` : '/api/graph-data';
                console.log(`📡 API URL: ${apiUrl}`);
                
                console.log('📞 Sending API request...');
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                console.log('✅ API response successful, parsing JSON...');
                const data = await response.json();
                console.log('📊 Received data:', {
                    entities: data.entities?.length || 0,
                    relationships: data.relationships?.length || 0,
                    fixes: data.fixes_applied || 0
                });
                
                // Check if this is an empty graph response
                if (data.empty_graph) {
                    // Handle empty graph case
                    document.getElementById('file-info').textContent = `知識圖譜可視化 (精簡版) - 暫無資料`;
                    document.getElementById('stats').textContent = `沒有可用的圖譜資料。請上傳 JSON 格式的圖譜檔案來開始視覺化。`;
                    
                    // Show empty state message in the visualization area
                    svg.selectAll('*').remove();
                    const width = parseInt(svg.attr('width'));
                    const height = parseInt(svg.attr('height'));
                    
                    svg.append('text')
                        .attr('x', width / 2)
                        .attr('y', height / 2)
                        .attr('text-anchor', 'middle')
                        .attr('font-family', 'Arial, sans-serif')
                        .attr('font-size', '18px')
                        .attr('fill', '#666')
                        .text('暫無圖譜資料');
                    
                    svg.append('text')
                        .attr('x', width / 2)
                        .attr('y', height / 2 + 30)
                        .attr('text-anchor', 'middle')
                        .attr('font-family', 'Arial, sans-serif')
                        .attr('font-size', '14px')
                        .attr('fill', '#999')
                        .text('請上傳 JSON 格式的圖譜檔案來開始視覺化');
                    
                    console.log('✅ Empty graph state displayed');
                    return;
                }
                
                // Update file info display
                const sourceFile = data.source_file || '預設檔案';
                document.getElementById('file-info').textContent = `基於 ${sourceFile} 的知識圖譜可視化 (精簡版)`;
                console.log(`📝 Updated file info display: ${sourceFile}`);
                
                // Check if server applied fixes
                if (data.fixes_applied > 0) {
                    console.log(`✅ Server automatically fixed ${data.fixes_applied} missing entities`);
                    console.log('Fixed entities:', data.missing_entities_found);
                    
                    // Show notification to user
                    document.getElementById('stats').textContent = `正在處理數據... (已自動修復 ${data.fixes_applied} 個數據不一致問題)`;
                }
                
                console.log('🔧 Starting data processing...');
                processData(data);
                
                console.log('🎨 Starting visualization creation...');
                createVisualization();
                
                console.log('📊 Updating statistics...');
                updateStats();
                
                console.log('✅ Simple viewer loading completed!');
                
            } catch (error) {
                console.error('❌ Simple viewer loading error:', error);
                console.error('Error details:', error.stack);
                document.getElementById('stats').textContent = `載入失敗：${error.message}`;
            }
        }
        
        // Process raw data into visualization format
        function processData(rawData) {
            console.log('🔧 Starting raw data processing...');
            console.log('📊 Raw data structure:', {
                hasEntities: !!rawData.entities,
                hasRelationships: !!rawData.relationships,
                entitiesType: typeof rawData.entities,
                relationshipsType: typeof rawData.relationships,
                entitiesLength: rawData.entities?.length,
                relationshipsLength: rawData.relationships?.length
            });
            
            if (!rawData.entities || !Array.isArray(rawData.entities)) {
                console.error('❌ Invalid entities data:', rawData.entities);
                throw new Error('Entity data format error');
            }
            
            if (!rawData.relationships || !Array.isArray(rawData.relationships)) {
                console.error('❌ Invalid relationships data:', rawData.relationships);
                throw new Error('Relationship data format error');
            }
            
            console.log('✅ Data format validation passed');
            
            // Create nodes from entities
            console.log('🔨 Creating node data...');
            nodes = rawData.entities.map((entity, index) => {
                const node = {
                    id: entity,
                    name: entity,
                    type: classifyEntity(entity),
                    group: Math.floor(index / 50) // Group for force layout
                };
                
                if (index < 5) { // Log detailed info for first 5 nodes only
                    console.log(`  Node ${index + 1}: ${entity} (type: ${node.type})`);
                }
                
                return node;
            });
            
            console.log(`✅ Successfully created ${nodes.length} nodes`);
            
            // Create links from relationships
            console.log('🔗 Creating relationship data...');
            let validLinks = 0;
            let invalidLinks = 0;
            
            links = rawData.relationships.map((rel, index) => {
                const parts = rel.split(' - ');
                if (parts.length >= 3) {
                    const link = {
                        source: parts[0],
                        target: parts[2],
                        relationship: parts[1]
                    };
                    
                    if (index < 5) { // Log detailed info for first 5 relationships only
                        console.log(`  Relationship ${index + 1}: ${link.source} -> ${link.target} (${link.relationship})`);
                    }
                    
                    validLinks++;
                    return link;
                } else {
                    console.warn(`⚠️ Invalid relationship format: ${rel}`);
                    invalidLinks++;
                    return null;
                }
            }).filter(link => link !== null);
            
            console.log(`✅ Successfully created ${links.length} valid relationships (invalid: ${invalidLinks})`);
            console.log(`🔧 Data processing completed: ${nodes.length} nodes, ${links.length} relationships`);
        }
        
        // Classify entities for color coding
        function classifyEntity(entity) {
            if (entity.includes('隱') || entity.includes('村') || entity.includes('英蓮') || 
                entity.includes('封氏') || entity.includes('曹雪芹')) {
                return 'person';
            }
            if (entity.includes('廟') || entity.includes('山') || entity.includes('峰') || 
                entity.includes('巷') || entity.includes('門') || entity.includes('京城')) {
                return 'location';
            }
            if (entity.includes('《') && entity.includes('》')) {
                return 'literature';
            }
            if (entity.includes('夢') || entity.includes('情') || entity.includes('詩') ||
                entity.includes('功名') || entity.includes('富貴')) {
                return 'concept';
            }
            return 'other';
        }
        
        // Create the main visualization
        function createVisualization() {
            console.log('🎨 Starting visualization creation...');
            
            const width = parseInt(svg.attr('width'));
            const height = parseInt(svg.attr('height'));
            console.log(`📐 Canvas dimensions: ${width} x ${height}`);
            
            if (!nodes || nodes.length === 0) {
                console.error('❌ Node data is empty, cannot create visualization');
                throw new Error('Node data is empty');
            }
            
            if (!links || links.length === 0) {
                console.error('❌ Relationship data is empty, cannot create visualization');
                throw new Error('Relationship data is empty');
            }
            
            console.log(`🔧 Preparing to create force-directed graph: ${nodes.length} nodes, ${links.length} relationships`);
            
            try {
                // Clear any existing visualization
                svg.selectAll('*').remove();
                console.log('🧹 Cleared old visualization elements');
                
                // Initialize force simulation
                console.log('⚡ Initializing force simulation...');
                simulation = d3.forceSimulation(nodes)
                    .force('link', d3.forceLink(links)
                        .id(d => d.id)
                        .distance(60)
                        .strength(0.5)
                    )
                    .force('charge', d3.forceManyBody()
                        .strength(-100)
                        .distanceMax(200)
                    )
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collision', d3.forceCollide().radius(15));
                
                console.log('✅ Force simulation initialized successfully');
                
                // Create link elements
                console.log('🔗 Creating relationship visualization elements...');
                const linkElements = svg.append('g')
                    .attr('class', 'links')
                    .selectAll('line')
                    .data(links)
                    .enter().append('line')
                    .attr('class', 'link');
                
                console.log(`✅ Successfully created ${linkElements.size()} relationship lines`);
                
                // Create node elements
                console.log('⭕ Creating node visualization elements...');
                const nodeElements = svg.append('g')
                    .attr('class', 'nodes')
                    .selectAll('circle')
                    .data(nodes)
                    .enter().append('circle')
                    .attr('class', 'node')
                    .attr('r', d => Math.max(4, Math.min(12, d.name.length)))
                    .style('fill', d => colorScheme[d.type] || colorScheme.other)
                    .call(createDragBehavior())
                    .on('mouseover', showTooltip)
                    .on('mouseout', hideTooltip);
                
                console.log(`✅ Successfully created ${nodeElements.size()} node circles`);
                
                // Create label elements (only for important nodes)
                console.log('🏷️ Creating label elements...');
                const shortNameNodes = nodes.filter(d => d.name.length <= 4);
                console.log(`📝 Will create labels for ${shortNameNodes.length} short-name nodes`);
                
                const labelElements = svg.append('g')
                    .attr('class', 'labels')
                    .selectAll('text')
                    .data(shortNameNodes)
                    .enter().append('text')
                    .attr('class', 'node-label')
                    .text(d => d.name)
                    .style('font-size', '8px');
                
                console.log(`✅ Successfully created ${labelElements.size()} labels`);
                
                // Update positions on each tick
                console.log('🔄 Setting up animation update function...');
                let tickCount = 0;
                simulation.on('tick', () => {
                    tickCount++;
                    
                    linkElements
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);
                    
                    nodeElements
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);
                    
                    labelElements
                        .attr('x', d => d.x)
                        .attr('y', d => d.y + 15);
                    
                    // Log only first few ticks
                    if (tickCount <= 5) {
                        console.log(`🔄 Tick ${tickCount}: Position update completed`);
                    }
                });
                
                console.log('✅ Visualization creation completed!');
                
            } catch (error) {
                console.error('❌ Error occurred during visualization creation:', error);
                throw error;
            }
        }
        
        // Create drag behavior for nodes
        function createDragBehavior() {
            return d3.drag()
                .on('start', function(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                })
                .on('drag', function(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                })
                .on('end', function(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                });
        }
        
        // Show tooltip on hover
        function showTooltip(event, d) {
            const tooltip = d3.select('.tooltip');
            const connectedLinks = links.filter(link => 
                link.source.id === d.id || link.target.id === d.id
            );
            
            tooltip.transition().duration(200).style('opacity', 1);
            tooltip.html(`
                <strong>${d.name}</strong><br/>
                類型: ${getTypeLabel(d.type)}<br/>
                連接數: ${connectedLinks.length}
            `)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 10) + 'px');
        }
        
        // Hide tooltip
        function hideTooltip() {
            d3.select('.tooltip').transition().duration(200).style('opacity', 0);
        }
        
        // Get Chinese type label
        function getTypeLabel(type) {
            const labels = {
                person: '人物',
                location: '地點',
                literature: '文學作品',
                concept: '概念',
                other: '其他'
            };
            return labels[type] || '未知';
        }
        
        // Update statistics display
        function updateStats() {
            console.log('📊 Updating statistics...');
            
            try {
                const statsElement = document.getElementById('stats');
                if (!statsElement) {
                    console.error('❌ Cannot find statistics display element');
                    return;
                }
                
                const entityCounts = {
                    person: nodes.filter(n => n.type === 'person').length,
                    location: nodes.filter(n => n.type === 'location').length,
                    literature: nodes.filter(n => n.type === 'literature').length,
                    concept: nodes.filter(n => n.type === 'concept').length,
                    other: nodes.filter(n => n.type === 'other').length
                };
                
                console.log('📈 Entity type statistics:', entityCounts);
                
                const statsText = `實體: ${nodes.length} | 關係: ${links.length} | 人物: ${entityCounts.person} | 地點: ${entityCounts.location} | 文學作品: ${entityCounts.literature}`;
                statsElement.textContent = statsText;
                
                console.log('✅ Statistics updated:', statsText);
                
            } catch (error) {
                console.error('❌ Error occurred while updating statistics:', error);
            }
        }
        
        // Control functions
        function restartSimulation() {
            if (simulation) {
                simulation.alpha(1).restart();
            }
        }
        
        function pauseResume() {
            if (simulation) {
                isPaused = !isPaused;
                if (isPaused) {
                    simulation.stop();
                } else {
                    simulation.restart();
                }
            }
        }
        
        function centerView() {
            if (svg) {
                svg.transition().duration(750).call(
                    d3.zoom().transform,
                    d3.zoomIdentity
                );
            }
        }
        
        // Initialize when page loads
        window.onload = function() {
            console.log('🔍 Checking D3.js loading status...');
            if (checkD3()) {
                initWhenReady();
            }
        };
    </script>
</body>
</html> 